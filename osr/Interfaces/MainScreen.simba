(*
MainScreen
==========

This file holds functions and procedures that are used for the mainscreen.

 * Ouputs a global variable 'MainScreen' that should be used to call these methods.

.. code-block:: pascal

    srl.Writeln(MainScreen.GetUpText());
*)
type
  THPBar = record
    Bounds: TBox;
    Percent: Extended;
 end;

type
  THPBarArray = array of THPBar;

type
  TRSMainScreen = record(TInterfaceBase)
    UpTextArea: TBox;
 end;

var
  MainScreen: TRSMainScreen;

{$IFNDEF CODEINSIGHT}
procedure TRSMainScreen.__Setup();
begin
  with Self do
  begin
    SetName('Mainscreen');
    SetStatic(True);
    SetBounds([4, 4, 515, 337]);

    UpTextArea := [7, 7, 465, 25];
  end;
end;
{$ENDIF}

(*
MainScreen.GetUpText
~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMainScreen.GetUpText(): String;

Returns the current uptext (Text in top left of the screen).

Example:

.. code-block:: pascal

    srl.Writeln(MainScreen.GetUpText());
*)
function TRSMainScreen.GetUpText(): String;
const
  OCR_RULES_UPTEXT: TCompareRules = [-1, 75, True, 55];
var
  x: Int32;
begin
  Result := OCR.Recognize(Self.UpTextArea, OCR_RULES_UPTEXT, UpFont);
  if (x := Pos('more options', Result)) <> 0 then
    SetLength(Result, x + length('more options') - 1);

  {$IFDEF UPTEXT_DEBUG}
    srl.Writeln('UpText found: ' + Result);
  {$ENDIF}
end;

(*
MainScreen.IsUpText
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMainScreen.IsUpText(SubStrs: TStringArray; WaitTime: UInt32 = 260): Boolean;

Returns True if any of the strings in 'SubStrs' is in the uptext. Will search up to 'WaitTime'
which by default is 260.

Example:

.. code-block:: pascal

    if (MainScreen.IsUpText(['Attack Chicken', 'ack Chicken'])) then
      Mouse.Click(mouse_Left);
*)
function TRSMainScreen.IsUpText(SubStrs: TStringArray; WaitTime: UInt32 = 260): Boolean;
var
  TimeOut: UInt64;
begin
  Result := False;
  TimeOut := GetTickCount64() + (WaitTime + Random(50));

  while (TimeOut >= GetTickCount64()) do
  begin
    if (IsArrInStr(SubStrs, Self.GetUpText())) then
      Exit(True);

    Wait(Random(35, 95));
  end;
end;

(*
MainScreen.IsUpText; overload
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMainScreen.IsUpText(Str: String; WaitTime: UInt32 = 270): Boolean; overload;

Returns True if any of the string 'Str' is in the uptext. Will search up to 'WaitTime'
which by default is 270.

Example:

.. code-block:: pascal

    if (MainScreen.IsUpText('Attack Chicken')) then
      Mouse.Click(mouse_Left);
*)
function TRSMainScreen.IsUpText(Str: String; WaitTime: UInt32 = 270): Boolean; overload;
begin
  Result := Self.IsUpText([Str], WaitTime);
end;

(*
MainScreen.GetPlayerBox
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMainScreen.GetPlayerBox(): TBox;

Returns of a rough Area (TBox) on where your player is.

Example:

.. code-block:: pascal

    Writeln(MainScreen.GetPlayerBox());
*)
function TRSMainScreen.GetPlayerBox(): TBox;
begin
  with Self.GetMiddle() do
    Result := [X - 40, Y - 40, X + 40, Y + 40];
end;

(*
MainScreen.FilterPlayerBox
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure TRSMainScreen.FilterPlayerBox(var TPA: TPointArray);

Removes all points in the TPointArray 'TPA' that are in the player box.

Example:

.. code-block:: pascal

    MainScreen.FilterPlayerBox(TPA);
*)
procedure TRSMainScreen.FilterPlayerBox(var TPA: TPointArray);
begin
  TPA := ClearTPAFromTPA(TPA, TPAFromBox(Self.GetPlayerBox()));
end;

(*
MainScreen.FindHPBars
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMainScreen.FindHPBars(Area: TBox): THPBarArray;

Returns a THPBarArray of all hitpoint bars found in the area 'Area'.
  * THPBar.Bounds is the bounds of the found hitpoint bar
  * THPBar.Percent is the percent of health in the hitpoint bar.

Example:

.. code-block:: pascal

    Bars := MainScreen.FindHPBars(MainScreen.GetBounds());
*)
function TRSMainScreen.FindHPBars(const Area: TBox): THPBarArray;

  function _FixHPBars(var Bars: T2DIntArray; TPA: TPointArray): TPointArray;
  var i: Int32;
  begin
    FilterPointsBox(TPA, 1, 0, High(Bars[0]), High(Bars));
    SortTPAByX(TPA, True);

    for i := 0 to High(TPA) do
      if (Bars[TPA[i].y][TPA[i].x - 1] <> 0) then
        Bars[TPA[i].y][TPA[i].x] := 255;
  end;

  procedure _FindHPBars(var Bars: T2DIntArray; var Result: THPBarArray);
  const
    W = 29;
    H = 4;
  var
    wid, hei, y, x, yy: Int32;
    bad: Boolean;
  begin
    wid := Length(bars[0])-W-1;
    hei := Length(bars)-5;
    for y := 1 to hei do
      for x := 1 to wid do
        if (Bars[y][x] <> 0) and (Bars[y][x+w] <> 0) then
          Bars[y][x] := 254;

    for y := 1 to hei do
      for x := 1 to wid do
        if (Bars[y][x] = 254) and ((Bars[y][x-1] = 0) or (Bars[y][x+1] = 255)) then
        begin
          bad := False;
          for yy := max(y-h,0) to y do
            if Bars[yy][x] = $00FF00 then
            begin
              bad := True;
              Break;
            end;

          if (not bad) then
          begin
            Bars[y][x] := $00FF00;
            Result += THPBar([TBox([x, y, x + W, y + H]), 0.00]);
          end;
        end;
  end;

const
  COLOR_BARS = [$00FF00, $0000FF];
  COLOR_SPLATS = [16728128, 11339523, 5571843, 192, 197503, 65889, $FFFFFF, 0];
var
  i: Int32;
  tmp, TPA, Splats: TPointArray;
  Mat: T2DIntArray;
  B: TBox;
begin
  Freeze();

  try
    for i := 0 to High(COLOR_BARS) do
      if (FindColors(tmp, COLOR_BARS[i], Area)) then
        Insert(tmp, TPA, Length(TPA) + 1);

    for i := 0 to High(COLOR_SPLATS) do
      if (FindColors(tmp, COLOR_SPLATS[i], Area)) then
        Insert(tmp, Splats, Length(Splats) + 1);

    if (Length(TPA) < 10) then
      Exit;

    B := GetTPABounds(TPA);
    OffsetTPA(Splats, Point(-B.X1+1,-B.Y1+1));
    SetLength(Mat, B.Height()+2, B.Width()+2);
    for i := 0 to High(TPA) do
      Mat[(TPA[i].y-B.Y1)+1][(TPA[i].x-B.X1)+1] := 255;

    _FixHPBars(Mat, Splats);
    _FindHPBars(Mat, Result);

    for i := High(Result) downto 0 do
    begin
      if (Mat[Result[i].Bounds.Y1, Result[i].Bounds.X1] = 0) or
         (Mat[Result[i].Bounds.Y1, Result[i].Bounds.X2] = 0) or
         (Mat[Result[i].Bounds.Y2, Result[i].Bounds.X2] = 0) or
         (Mat[Result[i].Bounds.Y2, Result[i].Bounds.X1] = 0) then
       Delete(Result, i, 1)
      else
        with Result[i] do
        begin
          Area.Offset([B.X1-1, B.Y1-1]);

          if (FindColors(TPA, $00FF00, Area)) then
            Percent := (GetTPABounds(TPA).Width / 30) * 100;
        end;
    end;
  finally
    Unfreeze();
  end;
end;

begin
  MainScreen.__Setup();
end;
