type
  TOption = record
    str: String;
    bounds: TBox;
  end;
  TOptionArray = Array of TOption;

  TRSChooseOption = type TBox;

var
  ChooseOption: TRSChooseOption;

  BMP_ChooseOption: Int32;
  BMP_ChooseOption_Width:Int32;
  BMP_ChooseOption_Height:Int32;

{$IFNDEF CODEINSIGHT}
procedure TRSChooseOption.__setup();
begin
  BMP_ChooseOption := BitmapFromString(20, 18, 'meJxzD4l1pwAxkAsGj15Mv+DyGp' +
        'ogXBmyemL04lEzgHqxhgPxehkwwoEkN9NCLwMRcYRHL5rvSNVLPBhAvWQjAO6IcGE=');
  GetBitmapSize(BMP_ChooseOption, BMP_ChooseOption_Width, BMP_ChooseOption_Height);
end;

procedure TRSChooseOption.__free(); 
begin 
  FreeBitmap(BMP_ChooseOption); 
end;
{$ENDIF}


function TRSChooseOption.__find(var Pos:TPoint; tryTime:Int32=-1): Boolean;
var 
  t: UInt64;
begin
  if tryTime < 0 then
    tryTime := Random(1500,2500);

  t := GetTickCount64() + tryTime;
  repeat
    Result := FindBitmap(BMP_ChooseOption, pos.x, pos.y);
    if Result then
    begin
      pos.y += BMP_ChooseOption_Height;
      Exit;
    end;
  until (GetTickCount64() > t);
end;


function TRSChooseOption.IsOpen(tryTime:Int32=-1): Boolean;
var pt:TPoint;
begin
  if tryTime < 0 then
    tryTime := Random(1500,2500);
  Result := self.__find(pt, tryTime);
end;


function TRSChooseOption.IsClosed(maxWaitTime:Int32=-1; IntervalMS:Int32=25): Boolean;
var t:UInt64;
begin
  if maxWaitTime < 0 then
    maxWaitTime := Random(1500,2500);
  t := GetTickCount64() + maxWaitTime;
  while self.IsOpen(1) and (GetTickCount64() < t) do
    Wait(IntervalMS);
  Result := not(self.IsOpen(1));
end;


function TRSChooseOption.Find(): Boolean;
var
  pt: TPoint;
  B:TBox;
  TPA:TPointArray;
  ATPA:T2DPointArray;
begin
  Self := [0,0,0,0];
  Result := Self.__find(pt);
  if Result then
  begin
    B := GetClientBounds(True);
    FindColors(TPA, 0, pt.x,pt.y,B.x2,B.y2);
    ATPA := ClusterTPAEx(TPA,1,1);
    SortATPAFrom(ATPA,pt);
    if Length(ATPA) = 0 then 
      RaiseException(erException,'No wai!! This is bullshit'); 
      
    Self := GetTPABounds(ATPA[0]);
    Self.Expand(1);
    Self.LimitTo(B);
  end;
end;


function TRSChooseOption.GetOptions(): TOptionArray;
var
  b: TBox;
  i,bmp,oldT,T:Int32;
begin
  if not(self.Find()) then
    Exit();
  WriteLn(Self,', ', GetClientBounds(True));

  bmp := BitmapFromClient(Self.x1,Self.y1,Self.x2,Self.y2);
  FastReplaceColor(bmp,4674653,0);
  ThresholdAdaptiveBitmap(bmp,0,255,False,TM_Mean,-1);
  //set image as target
  oldT := GetImageTarget();
  T := SetTargetBitmap(bmp);
  SetImageTarget(T);

  SetLength(Result, (Self.y2 - Self.y1 + 1) div 15);
  for i:=0 to High(Result) do
  begin
    with B do
    begin
      x1 := 2;
      y1 := i * 15 + 2;
      x2 := (Self.x2 - Self.x1) - 2;
      y2 := y1 + 15;
    end;
    Result[i].str := GetTextAt(B.x1,B.y1+1, 0,3,2, 255, 0,150,'UpChars07');
    B.Offset(Point(Self.x1, Self.y1));
    Result[i].bounds := B;
  end;
  //return to old target
  FreeTarget(T);
  SetImageTarget(oldT);
  FreeBitmap(bmp);
end;


function TRSChooseOption.Open(tryTime:Int32=-1): Boolean;
var _:TPoint;
begin
  Mouse.Click(mouse_right);
  Result := self.__find(_, tryTime);
end;


function TRSChooseOption.Close(): Boolean;
var
  i,minV,minI:Int32;
  B,clientB:TBox;
  pt:TPoint;
  dist:Array [0..3] of Int32;
const
  MIN_MOUSE_OFFSET = 30;
  RND = 40;
begin
  B := [Self.x1,self.y1-BMP_ChooseOption_Height,self.x2,self.y2];
  B.Expand(MIN_MOUSE_OFFSET);

  clientB := GetClientBounds(True);
  pt := Mouse.getPosition();

  dist := [abs(pt.x - B.x1), abs(pt.y - B.y1), abs(pt.y - B.y2),abs(pt.x - B.x2)];
  minv := Min(Min(dist[0],dist[2]),Min(dist[1],dist[3]));
  if B.x1 < clientB.x1 then dist[0] := High(Int32); //left
  if B.y1 < clientB.y1 then dist[1] := High(Int32); //top
  if B.x2 > clientB.x2 then dist[2] := High(Int32); //right
  if B.y2 > clientB.y2 then dist[3] := High(Int32); //bottom

  for i:=0 to 3 do
    if dist[i] < dist[minI] then
      minI := i;

  case minI of
    0: pt := [B.x1-Random(RND), pt.y+Random(-RND,RND)]; //left
    1: pt := [pt.x+Random(-RND,RND), B.y1-Random(RND)]; //top
    2: pt := [B.x2+Random(RND), pt.y+Random(-RND,RND)]; //right
    3: pt := [pt.x+Random(-RND,RND), B.y2+Random(RND)]; //bottom
  end;
  Mouse.Move(Point(
      max(clientB.x1, min(pt.x, clientB.x2)),
      max(clientB.y1, min(pt.y, clientB.y2))
    ));

  Result := self.IsClosed();
  if not(Result) then
  begin
    self.Select(['Cancel']);
    Result := self.IsClosed();
  end;
end;


function TRSChooseOption.Select(SubStrings:TStringArray; mouseAction:Integer=mouse_left; AClose:Boolean=True; CaseSensitive:Boolean=True): Boolean;
var
  Choices: TOptionArray;
  i,j,L:Int32;
begin
  Choices := Self.GetOptions();
  L := Length(Choices);
  if L = 0 then
    Exit(False);

  for i:=0 to L-1 do
    for j:=0 to High(SubStrings) do
      case CaseSensitive of
        True:
          if Pos(SubStrings[j],Choices[i].str)<>0 then
          begin
            Mouse.Click(Choices[i].bounds, mouseAction);
            Exit(True);
          end;
        False:
          if Pos(Lowercase(SubStrings[j]),Lowercase(Choices[i].str))<>0 then
          begin
            Mouse.Click(Choices[i].bounds, mouse_left);
            Exit(True);
          end;
      end;

  if AClose then
    Self.Close();
end;

begin
  ChooseOption.__setup();
  AddOnTerminate(@ChooseOption.__free);
end;


