const
  DIR_NORTH = 0.00;
  DIR_EAST  = 90.0;
  DIR_SOUTH = 180.0;
  DIR_WEST  = 270.0;

type
  EMinimapOrb = (orbHP, orbPrayer, orbRun);

type
  TMMOrbInfo = record
    TextBox: TBox;
    Middle: TPoint;
    Radius: Byte;
 end;

type
  TMMCompassInfo = record
    Middle: TPoint;
    Bounds: TBox;
    Radius: Byte;
 end;

  TMinimap = record (TInterfaceBase)
    CompassInfo: TMMCompassInfo;
    OrbInfo: array [0..High(EMinimapOrb)] of TMMOrbInfo;
 end;

var
  Minimap: TMinimap;

procedure TMinimap.__Setup();
begin
  with (Self) do
  begin
    setName('Minimap');
    setStatic(True);
    setBounds([570, 9, 716, 155]);

    with (CompassInfo) do
    begin
      Bounds := [544, 3, 579, 38];
      Middle := [561, 20];
      Radius := 15;
    end;

    with (OrbInfo[Ord(orbHP)]) do
    begin
      Middle := [581, 136];
      Radius := 15;
      TextBox := [520, 55, 539, 68];
    end;

    with (OrbInfo[Ord(orbPrayer)]) do
    begin
      Middle := [581, 136];
      Radius := 15;
      TextBox := [521, 99, 540, 112];
    end;

    with (OrbInfo[Ord(orbRun)]) do
    begin
      Middle := [581, 136];
      Radius := 11;
      TextBox := [545, 135, 564, 148];
    end;
  end;
end;

function TMinimap._GetOrbValue(const orb: EMinimapOrb): Integer;
const
  IgnoreCols = [4938344, 0];
  Font = 'StatChars07';
var
  ATPA: array [0..1] of TPointArray;
  TextTPA: TPointArray;
  i: Integer;
begin
  for i := 0 to High(IgnoreCols) do
    FindColors(ATPA[i], IgnoreCols[i], OrbInfo[Ord(orb)].TextBox);

  TextTPA := ReturnPointsNotInTPA(MergeATPA(ATPA), OrbInfo[Ord(orb)].TextBox);
  Result := StrToIntDef(srl.GetTextFromTPA(TextTPA, 1, 3, 100, Font), 0);
end;

function TMinimap.GetPrayerLevel(): Integer;
begin
  Result := Self._GetOrbValue(orbPrayer);
end;

function TMinimap.GetHPLevel(): Integer;
begin
  Result := Self._GetOrbValue(orbHP);
end;

function TMinimap.GetHPPercent(): Integer;
var
  tb, b:TBox;
  TPA:TPointArray;
begin
  b := [543,45,568,70];
  FindColorsTolerance(TPA,1250067,b,20);
  tb := GetTPABounds(TPA);
  Result := 100 - Ceil((tb.y2-tb.y1) / (b.y2-b.y1) * 100);
end;

function TMinimap.GetRunEnergy(): Integer;
begin
  Result := Self._GetOrbValue(orbRun);
end;

function TMinimap.isRunEnabled(const Time: UInt32 = 0): Boolean;
const
  Col = 6806252;
  Tol = 15;
  MinCount = 10;
var
  b: TBox;
begin
  with (Self.OrbInfo[Ord(orbRun)].Middle) do
    b := [X - 6, Y - 6, X + 6, Y + 6];

  if (Time = 0) then
    Result := (CountColorTolerance(Col, b, Tol) > MinCount)
  else
    Result := srl.WaitMinColorCount(Col, Tol, b, MinCount, Time);
end;

function TMinimap.ToggleRun(const Enable: Boolean): Boolean;
begin
  Result := True;

  with (Self.OrbInfo[Ord(orbRun)]) do
  begin
    if (Enable) and (not Self.isRunEnabled()) then
    begin
      Mouse.Click(Middle, Radius, mouse_Left);
      Result := Self.isRunEnabled(Random(600, 1000));
    end
    else
    if (not Enable) and (Self.isRunEnabled()) then
    begin
      Mouse.Click(Middle, Radius, mouse_Left);
      Result := not Self.isRunEnabled(Random(250, 500));
    end;
  end;

  if (not Result) then
    srl.WriteFmt(Self.getName() + '.ToggleRun(): Failed to %s run',
                [BoolToStr(Enable, 'enable', 'disable')], TDebug.ERROR);
end;

function TMinimap.FindFlag(out p: TPoint): Boolean;
const
  PoleColor = 1127261;
  FlagColor = 255;
  LightPoleColor = 284358;
var
  TPA, TPAPoles: TPointArray;
  ATPA, ATPAColumns: T2DPointArray;
  i, j, Img: Integer;
begin
  p := [-1, -1];
  Img := BitmapFromClient(Self.getBounds());
  SetBitmapName(Img, 'Find flag bitmap');

  try
    if (not FindColorsBitmap(Img, TPA, PoleColor)) then
      Exit(False);

    with GetMufasaBitmap(Img) do
      for i := 0 to High(TPA) do
          if (GetPixel(TPA[i].x - 1, TPA[i].y) = FlagColor) or (GetPixel(TPA[i].x - 1, TPA[i].y) = LightPoleColor) and
             (GetPixel(TPA[i].X, TPA[i].y - 1) = PoleColor) or (GetPixel(TPA[i].x, TPA[i].y + 1) = PoleColor) then
                TPAPoles += TPA[i];

    if (Length(TPAPoles) = 0) then
      Exit(False);

    ATPAColumns := FindTPAColumns(TPAPoles);
    for i := 0 to High(ATPAColumns) do
    begin
      ATPA := SplitTPA(ATPAColumns[i], 1);

      for j := 0 to High(ATPA) do
        if (InRange(GetTPABounds(ATPA[j]).Height, 4, 20)) then
        begin
          Result := True;
          p := ATPA[j][0];

          while (p.y < (Self.getBounds().Height - 1)) and (FastGetPixel(Img, p.x, p.y) = PoleColor) do
            Inc(p.y);

          if (FastGetPixel(Img, p.x, p.y) <> PoleColor) then // Make sure we have the bottom of the pole
            Dec(p.y);
        end;
    end;
  finally
    FreeBitmap(Img);
  end;

  Inc(p.x, Self.GetBounds().X1);
  Inc(p.y, Self.GetBounds().Y1);
end;

procedure TMinimap.WaitFlag(const Dist: UInt32 = 0);
var
  TimeOut: UInt64;
  d, LastDist, SameDists: UInt32;
  p: TPoint;
begin
  TimeOut := GetTickCount64() + Random(10000, 12000);
  LastDist := 500;
  SameDists := 0;

  while (TimeOut > GetTickCount64()) and (Self.FindFlag(p)) do
  begin
    d := Distance(p, Self.getMiddle());
    if (d <= Dist) then
      Exit();

    if (d = LastDist) then
      Inc(SameDists)
    else
      SameDists := 0;

    if (SameDists >= 20) then
    begin
      srl.Writeln(Self.getName() + '.WaitFlag(): Distance between flag hasn''t changed in 20 loops, exiting.. ', TDebug.WARNING);
      Exit();
    end;

    LastDist := d;
    Wait(Random(50, 100));
  end;
end;

function TMinimap.GetCompassAngle(const AsDegrees: Boolean = True): Extended;

  function varMax(D: Array[0..2] of Single; a, b: Int32): Int32;
  begin
    if D[a] < D[b] then
      Exit(b)
    else
      Exit(a);
  end;

const
  PI_OVER_2 = PI / 2;
var
  i: Int32;
  D: Array[0..2] of Single;
  TPA, Dots: TPointArray;
  ATPA: T2DPointArray;
begin
  if (not FindColorsTolerance(TPA, 920735, Self.CompassInfo.Bounds, 45)) then
    Exit(srl.Writeln('Failed to find red compass dots color', 0.00, '', TDebug.WARNING));

  ATPA := SplitTPA(TPA, 6);                                                     // group the dots
  for i := 0 to High(ATPA) do                                                   // extract the 3 dots
    if (Length(ATPA[i]) <= 3) then
    begin
      SortTPAFrom(ATPA[i], Point(561, 20));
      Dots += ATPA[i][High(ATPA[i])];
    end;

  for i := 0 to 2 do                                                            // compute distance between each pair
    D[i] := Distance(Dots[i].x,Dots[i].y, Dots[(i+1) mod 3].x,Dots[(i+1) mod 3].y);

  i := varMax(D, varMax(D, 0, 1), varMax(D, varMax(D, 1, 2), varMax(D, 2, 0))); // find pair with largest distance between.
  i := (i + 2) mod 3;                                                           // we know it's not i, and not i+1 (so it must be i+2)
  Result := FixRad(ArcTan2((Dots[i].Y - Self.CompassInfo.Middle.Y),
                            Dots[i].X - Self.CompassInfo.Middle.X) - PI_OVER_2);
  if (AsDegrees) then
    Result := Round(Degrees(Result)) mod 360;
end;

function TMinimap.SetCompassAngle(Angle: Extended; Tolerance: Integer = 2): Boolean;

  function Compass_Distance(Angle, Target: Extended): Extended;
  begin
    if (Abs(Target - Angle) < 180) then
    begin
      Result := Target - Angle;
      Exit;
    end;

    if (Target > Angle) then
      Result := Target - Angle - 360
    else
      Result := Target - Angle + 360;
  end;

  procedure Key(Left: Boolean);
  begin
    case (Left) of
      True:
        if (not isKeyDown(VK_LEFT)) then
        begin
          if (isKeyDown(VK_RIGHT)) then
            KeyUp(VK_RIGHT);
          KeyDown(VK_LEFT)
        end;
      False:
        if (not isKeyDown(VK_RIGHT)) then
        begin
          if (isKeyDown(VK_LEFT)) then
            KeyUp(VK_LEFT);
          KeyDown(VK_RIGHT)
        end;
    end;
  end;

var
  TimeOut: UInt64;
  CurrentAngle, AngleDistance: Extended;
  Left: Boolean;
begin
  Angle := FixD(Angle);
  CurrentAngle := Self.GetCompassAngle();
  if (CurrentAngle = Angle) then
    Exit(True);

  TimeOut := GetTickCount64() + Random(13000, 17000);
  while (Abs(Compass_Distance(CurrentAngle, Angle)) > Tolerance) and (GetTickCount64() < TimeOut) do
  begin
    AngleDistance := CurrentAngle - Angle;
    Left := ((AngleDistance > 0) and (abs(AngleDistance) <= 180)) or ((AngleDistance < 0) and (abs(AngleDistance) > 180));
    Key(Left);

    CurrentAngle := Self.GetCompassAngle();
    Result := Abs(Compass_Distance(CurrentAngle, Angle)) <= Tolerance;
    if (Result) then
      Break();

    Wait(Random(15, 30));
  end;

  if (Left) then
    KeyUp(VK_LEFT)
  else
    KeyUp(VK_RIGHT);

  Wait(Random(270, 420));
end;

begin
  Minimap.__Setup();
end;




