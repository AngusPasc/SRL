const
  _LOGIN_TEXT_YELLOW = 65535;
  _LOGIN_TEXT_WHITE = 16777215;

type
  TRSLoginScreen = record(TInterfaceBase)
    LoginBox, PasswordBox, ResponseBox: TBox;
 end;

var
  LoginScreen: TRSLoginScreen;

procedure TRSLoginScreen.__Setup();
begin
  with (Self) do
  begin
    setName('Login screen');
    setStatic(True);
    setBounds(srl.DefaultClientBounds);

    LoginBox := [312, 254, 550, 266];
    PasswordBox := [341, 271, 550, 285];
    ResponseBox := [210, 208, 550, 233];
  end;
end;

function TRSLoginScreen.isOpen(const WaitTime: UInt32 = 0): Boolean;
var
  TPA: TPointArray;
  TimeOut: UInt64;
begin
  Result := False;
  TimeOut := GetTickCount64() + WaitTime;

  repeat
    Freeze(); // Why return data twice? :)

    try
      Result := srl.FindText(TPA, 'Welcome to RuneScape', 'UpChars07', _LOGIN_TEXT_YELLOW, 0, Self.getBounds()) or
                srl.FindText(TPA, 'Login:', 'UpChars07', _LOGIN_TEXT_WHITE, 0, Self.getBounds());

      Result := Result and (Length(TPA) = 1);
    finally
      Unfreeze();
    end;
  until (Result) or (GetTickCount64() >= TimeOut);
end;

function TRSLoginScreen.isLoginOpen(): Boolean;
var
  TPA: TPointArray;
  Timeout: UInt64;
begin
  Result := False;
  Timeout := GetTickCount64() + Random(3500, 4500);

  while (not Result) and (Timeout > GetTickCount64()) do
  begin
    Result := srl.FindText(TPA, 'Login:', 'UpChars07', _LOGIN_TEXT_WHITE, 0, Self.getBounds());
    Result := Result and (Length(TPA) = 1);

    Wait(Random(100, 200));
  end;
end;

function TRSLoginScreen.GetCursor(): Byte;
var
  TimeOut: UInt64;
begin
  TimeOut := GetTickCount64() + Random(3000, 4000);

  repeat
    if (CountColor(_LOGIN_TEXT_YELLOW, Self.LoginBox) > 10) then
      Exit(0);
    if (CountColor(_LOGIN_TEXT_YELLOW, Self.PasswordBox) > 10) then
      Exit(1);

    Wait(Random(33, 66));
  until (GetTickCount64() > TimeOut);
end;

procedure TRSLoginScreen.SetCursor(const New: Integer);
begin
  if (Self.GetCursor() <> New) then
    while (Self.GetCursor() <> New) do
    begin
      Keyboard.PressKey(VK_BACK);
      Wait(Random(350, 650));
    end;
end;

function TRSLoginScreen.EnterLoginInfo(Login, Pass: String; ClickLogin: Boolean = True): Boolean;

  function CursorInBox(b: TBox): Boolean;
  begin
    Result := srl.WaitMinColorCount(_LOGIN_TEXT_YELLOW, 5, b, 5, Random(1450, 1900));
  end;

  function SwitchCursor(): Boolean;
  begin
    Keyboard.PressKey(VK_TAB);
    Wait(Random(200, 500));
  end

const
  _LOGIN_BTN_OFFSET_Y = 300;
var
  Timeout: UInt64 := GetTickCount64() + Random(7500, 8000);
  b: TBox;
begin
  // ! ! !

  if (not Self.isLoginOpen()) then
    if (not srl.MouseText('Existing User', 'UpChars07', Self.getBounds(), mouse_Left)) then
      Exit(False);

  if (not Self.isLoginOpen()) then
    Exit(False);

  // Enter login
  if (not CursorInBox(Self.LoginBox)) then
    SwitchCursor();

  if (CountColor(_LOGIN_TEXT_WHITE, Self.LoginBox) > 0) then // Chars to delete
  begin
    while (CountColor(_LOGIN_TEXT_WHITE, Self.LoginBox) > 0) and (Timeout > GetTickCount64()) do
      Keyboard.PressKey(VK_BACK);
    Wait(Random(250, 650));
  end;

  Keyboard.Send(Login);
  Wait(Round(srl.TruncedGauss(100, 700)));
  Keyboard.PressKey(VK_ENTER);

  // Enter Password
  if (not CursorInBox(Self.PasswordBox)) then
    SwitchCursor();

  if (CountColor(_LOGIN_TEXT_WHITE, Self.PasswordBox) > 0) then // Chars to delete
  begin
    while (CountColor(_LOGIN_TEXT_WHITE, Self.PasswordBox) > 0) and (Timeout > GetTickCount64()) do
      Keyboard.PressKey(VK_BACK);
    Wait(Random(250, 650));
  end;

  Keyboard.Send(Pass);
  Wait(Round(srl.TruncedGauss(100, 1000)));
  Result := True;

  if (ClickLogin) then
  begin
    b := Self.getBounds();
    b.Y1 := _LOGIN_BTN_OFFSET_Y;

    if (Random(5) = 0) then
    begin
      if (not srl.MouseText('Login', 'UpChars07', b, mouse_Left)) then
        Keyboard.PressKey(VK_ENTER);  // Backup
    end else
      Keyboard.PressKey(VK_ENTER);
  end;
end;

function TRSLoginScreen.OpenWorldSwitcher(): Boolean;
begin
  if (not Self.isOpen()) then
    Exit(False);

  Result := srl.MouseText('Click to switch', 'StatChars07', clWhite, 0, Self.getBounds(), mouse_Left);
end;

function TRSLoginScreen.GetLoginResponse(): String;
begin
  with (Self.ResponseBox) do
    Result := Trim(GetTextAtEx(X1, Y1, X2, Y2, 0, 3, 3, _LOGIN_TEXT_YELLOW, 0, 'UpChars07_s'));
end;

{*
TRSLoginScreen._WaitResponse
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSLoginScreen._WaitResponse(): String;

Waits up to 12 seconds for a login response to appear. Will return the response.

.. note::

    - by Olly
    - Last Updated: 30 December 2014 by Olly

Example:

.. code-block:: pascal

*}
function TRSLoginScreen._WaitResponse(): String;
const
  VAILD_CONNECTING = 'Connecting to server...';
  VAILD_ENTER_INFO = 'Enter your username/email & password.';
var
  TimeOut: UInt64;
  Response: String;
begin
  TimeOut := GetTickCount64() + Random(13000, 15000);

  while (TimeOut > GetTickCount64()) do
  begin
    Response := Self.GetLoginResponse();

    if (Self.isOpen()) and (Response <> '') then
      if (Response <> VAILD_CONNECTING) and (Response <> VAILD_ENTER_INFO) then
      begin
        Wait(250);

        if (Self.GetLoginResponse() = Response) then
          Exit(Response);
      end;

    if (Lobby.isOpen()) then
      Exit('lobby');

    Wait(Random(500, 1000));
  end;

  srl.Writeln('No response found after 10 seconds', TDebug.WARNING);
end;

begin
  LoginScreen.__Setup();
end;
