type 
  TRSInventory = record(TInterfaceBase)
    FSlots: TBoxArray;
  end;

{
 procedure TRSInventory.__setup();
 function TRSInventory.Open(): Boolean;
 function TRSInventory.IsOpen(): Boolean;
 function TRSInventory.PointToSlot(pt:TPoint): Int32;
 function TRSInventory.IsFull(): Boolean;
 function TRSInventory.IsVaildSlot(idx: Int32): Boolean;
 function TRSInventory.GetSlotBox(idx:Int32): TBox;
 function TRSInventory.SlotIsUsed(idx:Int32): Boolean;
 function TRSInventory.GetUsedSlots(): TIntegerArray;
}

var 
  Inventory: TRSInventory;

const
    //Column wise (Z-style) and "reversed" column wise (S-style)
    DROP_PATTERN_REGULAR   = [0..27];
    DROP_PATTERN_REGULAR_R = [3,2,1,0, 7,6,5,4, 11,10,9,8, 15,14,13,12, 19,18,17,16, 23,22,21,20, 27,26,25,24];

    //Column wise (zigzag-style) and "reversed" version
    DROP_PATTERN_SNAKE   = [0,1,2,3, 7,6,5,4, 8,9,10,11, 15,14,13,12, 16,17,18,19, 23,22,21,20, 24,25,26,27];
    DROP_PATTERN_SNAKE_R = [3,2,1,0, 4,5,6,7, 11,10,9,8, 12,13,14,15, 19,18,17,16, 20,21,22,23, 27,26,25,24];

    //by row (and "reversed")
    DROP_PATTERN_TOPDOWN   = [0,4,8,12,16,20,24,  1,5,9,13,17,21,25,  2,6,10,14,18,22,26, 3,7,11,15,19,23,27];
    DROP_PATTERN_TOPDOWN_R = [3,7,11,15,19,23,27, 2,6,10,14,18,22,26, 1,5,9,13,17,21,25,  0,4,8,12,16,20,24];


{$IFNDEF CODEINSIGHT}
procedure TRSInventory.__setup();
var i:Int32;
begin
  self.FBounds := [558,211,725,462];
  self.FSlots := self.FBounds.Partition(7, 4, -2);
  for i:=0 to High(self.FSlots) do
  begin
    self.FSlots[i].x1 += 3;
    self.FSlots[i].x2 -= 3;
  end;
end;
{$ENDIF}


//given a pattern an a upper limit of "errors", it will swap around some values and return a "errorized" drop-pattern
function TRSInventory.ErrorPattern(Pattern: TIntegerArray=DROP_PATTERN_REGULAR; MaxErrors:Int32=5): TIntegerArray;
var i,j,h,errors:Integer;
begin
  Result := Copy(Pattern);
  h := High(Pattern);
  errors := Trunc(TruncedGauss(0,MaxErrors));
  for i:=1 to Errors do
  begin
    j := RandomRange(1,h);
    Swap(Result[j], Result[j-1]);
  end;
end;


function TRSInventory.Open(): Boolean;
begin
  Result := Gametabs.Open(tabInventory);
end;


function TRSInventory.IsOpen(): Boolean;
begin
  Result := Gametabs.IsOpen(tabInventory);
end;


function TRSInventory.PointToSlot(pt:TPoint): Int32;
var
  x,y,w:Int32;
const
  SLOT_WIDTH = 42; //inc. padding
  SLOT_HEIGHT= 36; //..
begin
  if not(PointInBox(Pt, Self.FBounds)) then
    Exit(-1);

  x := (Pt.x - Self.FBounds.x1) div SLOT_WIDTH;
  y := (Pt.y - Self.FBounds.y1) div SLOT_HEIGHT;
  w := (Self.FBounds.X2 - Self.FBounds.X1) + 1;
  Result := (y * (w div SLOT_WIDTH)) + x;
  if not(PointInBox(pt, Self.FSlots[Result])) then
    Result := -1;
end;


function TRSInventory.MouseSlot(idx:Int32): Int32;
begin
  if self.IsVaildSlot(idx) then
    Mouse.Move(self.FSlots[idx])
  else
    {notify index out of range};
end;


function TRSInventory.IsFull(): Boolean;
var
  i:Int32;
  b:TBox;
begin
  if not(self.Open()) then
    Exit();

  for i:=0 to High(self.FSlots) do
  begin
    b := self.FSlots[i];
    if (CountColor($10000, b.x1,b.y1,b.x2,b.y2) = 0) then
      Exit(False);
  end;
  Result := True;
end;


function TRSInventory.IsVaildSlot(idx: Int32): Boolean;
begin
  Result := InRange(idx, Low(Self.FSlots), High(Self.FSlots));
end;


function TRSInventory.GetSlotBox(idx:Int32): TBox;
begin
  if self.IsVaildSlot(idx) then
    Result := Self.FSlots[idx]
  else
    {notify index out of range};
end;


function TRSInventory.SlotIsUsed(idx:Int32): Boolean;
var b:TBox;
begin
  if not(self.Open()) then
    Exit();

  b := self.FSlots[idx];
  Result := CountColor($10000, b.x1,b.y1,b.x2,b.y2) > 0;
end;


function TRSInventory.GetUsedSlots(): TIntegerArray;
var i:Int32;
begin
  if not(self.Open()) then
    Exit();

  for i:=0 to High(self.FSlots) do
    if Self.SlotIsUsed(i) then
      Result += i;
end;


procedure TRSInventory.DropItems(slotArr:TIntegerArray = DROP_PATTERN_REGULAR);
var i:Int32;
begin
  if not(self.Open()) then
    Exit();

  for i:=0 to High(slotArr) do
    if self.SlotIsUsed(slotArr[i]) then
    begin
      if self.IsVaildSlot(slotArr[i]) then
      begin
        Mouse.Move(self.FSlots[slotArr[i]]);
        //Check uptext?
        ChooseOption.Open();
        ChooseOption.Select(['Drop']);
        wait(120 + random(100));
      end else
        {notify index out of range};
    end;
end;


procedure TRSInventory.DropItemsExcept(ignoreSlots:TIntegerArray; dropPattern:TIntegerArray = DROP_PATTERN_REGULAR);
var
  i:Int32;
  ptrn:TIntegerArray;
begin
  for i:=0 to High(dropPattern) do
    if not(InIntArray(ignoreSlots,dropPattern[i])) then
      ptrn += dropPattern[i];
  Self.DropItems(ptrn);
end;


begin
  Inventory.__setup();
end;
