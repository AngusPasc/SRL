type
  TCTSColor = record
    Color: Integer;
    Tolerance: Integer;
  end;

  TCTS1Color = type TCTSColor;

  TCTS2Color = record(TCTS1Color)
    HueMod, SatMod: Extended;
  end;

function _FindColors(var TPA: TPointArray; Area: TBox; Col, Tol, CTS: Integer; Hue, Sat: Extended = 0.00): UInt32;

  function SetCTS(CTS: Integer; Hue, Sat: Extended): Integer;
  begin
    Result := GetToleranceSpeed();
    SetColorToleranceSpeed(CTS);
    if (CTS = 2) then
      SetToleranceSpeed2Modifiers(Hue, Sat);
  end;

  procedure ResetCTS(CTS: Integer);
  begin
    if (CTS = 2) then
      SetToleranceSpeed2Modifiers(0.2, 0.2);
    SetColorToleranceSpeed(CTS);
  end;

begin
  SetLength(TPA, 0);

  CTS := SetCTS(CTS, Hue, Sat);
  FindColorsTolerance(TPA, Col, Area.X1, Area.Y1, Area.X2, Area.Y2, Tol);
  ResetCTS(CTS);

  Result := Length(TPA);
end;

function TSRL.FindColors(var TPA: TPointArray; Color: TCTSColor; Area: TBox): UInt32;
begin
  Result := _FindColors(TPA, Area, Color.Color, Color.Tolerance, 0);
end;

function TSRL.FindColors(var TPA: TPointArray; Color: TCTS1Color; Area: TBox): UInt32; overload;
begin
  Result := _FindColors(TPA, Area, Color.Color, Color.Tolerance, 1);
end;

function TSRL.FindColors(var TPA: TPointArray; Color: TCTS2Color; Area: TBox): UInt32; overload;
begin
  Result := _FindColors(TPA, Area, Color.Color, Color.Tolerance, 2, Color.HueMod, Color.SatMod);
end;

type
  TCompareFunc = function(X, Y: Integer): Boolean;

function GreaterThan(X, Y: Integer): Boolean; begin Result := X > Y; end;
function LessThan(X, Y: Integer): Boolean; begin Result := X < Y; end;
function Equals(X, Y: Integer): Boolean; begin Result := X = Y; end;

(*
srl.WaitColorCount
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TSRL.WaitColorCount(Color: TCTS1Color; Area: TBox; CompareFunc: TCompareFunc; Count, WaitTime: Integer): Boolean;

See examples. :)

Example:

.. code-block:: pascal

  // Waits 5000ms for the color count in area to be greater than 50
  srl.WaitColorCount([255, 10], Area, @GreaterThan, 50, 5000);

  // Waits 500ms for the color count in area to equal 20
  srl.WaitColorCount([255, 10], Area, @Equals, 20, 5000);
*)
function TSRL.WaitColorCount(Color: TCTS1Color; Area: TBox; CompareFunc: TCompareFunc; Count, WaitTime: Integer): Boolean;
var
  t: UInt64;
  TPA: TPointArray;
begin
  t := GetTickCount64() + WaitTime;
  repeat
    if (CompareFunc(FindColors(TPA, Color, Area), Count)) then
      Exit(True);
    Wait(Random(50, 100));
  until (GetTickCount64() >= t);
end;

(*
srl.WaitColor
~~~~~~~~~~~~~

.. code-block:: pascal

    function TSRL.WaitColor(Color: Integer; p: TPoint; WaitTime: Integer): Boolean;

Waits 'WaitTime' for the color 'Color' to be found at the point 'p'.

Example:

.. code-block:: pascal

    if (srl.WaitColor(clRed, Point(100, 100), 1000)) then
      Writeln('clRed has been found at point(100, 100) within 1 second');
*)
function TSRL.WaitColor(Color: Integer; pt: TPoint; WaitTime: Integer): Boolean;
var
  t: UInt64;
begin
  t := GetTickCount64() + WaitTime;
  repeat
    if (GetColor(pt.x, pt.y) = Color) then
      Exit(True);
    Wait(Random(50, 100));
  until (GetTickCount64() > t);
end;

function TSRL.WaitDTM(DTM: Integer; var pt: TPoint; Area: TBox; WaitTime: Integer): Boolean;
var
  t: UInt64;
begin
  t := GetTickCount64() + WaitTime;
  repeat
    if FindDTM(DTM, pt.x, pt.y, Area.X1, Area.Y1, Area.X2, Area.Y2) then
      Exit(True);
    Wait(Random(50, 100));
  until (GetTickCount64() > t);
end;

function TSRL.WaitBitmap(BMP, Tolerance: Integer; var pt: TPoint; Area: TBox; WaitTime: Integer): Boolean;
var
  t: UInt64;
begin
  t := GetTickCount64() + WaitTime;
  repeat
    if (FindBitmapToleranceIn(BMP, pt.x, pt.y, Area.X1, Area.Y1, Area.X2, Area.Y2, Tolerance)) then
      Exit(True);
    Wait(Random(50, 100));
  until (GetTickCount64() > t);
end;

