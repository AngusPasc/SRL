const
  __gauss_norm_0 = 0.029899776;
  __gauss_norm_1 = 0.008355968;
  __gauss_norm_2 = 0.076542912;
  __gauss_norm_3 = 0.252408784;
  __gauss_norm_4 = 3.949846138;

var
  __gaussPoint: Extended = 0.4;
  __gaussRange: Extended = 0.3;

function _gaussPoly(r, rsqr: Extended): Extended;
begin
  Result := __gauss_norm_0 * rsqr + __gauss_norm_1;
  Result := Result * rsqr + __gauss_norm_2;
  Result := Result * rsqr + __gauss_norm_3;
  Result := Result * rsqr + __gauss_norm_4;
  Result := Result * r;
end;

function _gaussRand(): Extended;
begin
  Result := sqrt(-2.0*ln(MaxE(Random(),3.72665E-6))) * cos(2.0*PI*Random());
end;

function gaussRand(mean, dev: Extended): Extended;
begin
  result := mean + dev * _gaussRand();
end;

(*
gauss
~~~~~

.. code-block:: pascal

    function gauss(): Extended;

Calculates a standard normal value (N(0, 1)). By definition, 68.2% of points
will lie within +/- 1*sigma, 95.4% within +/- 2.

.. note::

    - by: Nava2

*)
function gauss(): Extended;
var
  r: Extended;
  i: Integer;
begin
  r := 0.0;
  for i := 0 to 11 do
    r := r + (random(High(Integer))*1.0)/High(Integer);

  r := (r-6.0)/4.0 ;
  result := _gaussPoly(r, r*r);
end;

(*
gaussPoint
~~~~~~~~~~~

.. code-block:: pascal

    procedure gaussPoint(cX, cY: Integer; sAngle, eAngle: Extended; maxRad: Integer; out oX, oY: Integer);

Calculates a point about cX, cY with radius maxRad. The sangle and eangle are
in radians. The point is returned in the reference parameters oX, oY.

.. note::

    - by: Nava2

Example:

.. code-block:: pascal

    var
      gX, gY: Integer;
    begin
      // get a gaussian pt in a circle:
      gaussPoint(MMCX, MMCY, 0, math_2PI, MMX2-MMCX, gX, gY);
      WriteLn(Format("gX, gY -> %d, %d", gX, gY);
    end;
*)
procedure gaussPoint(cX, cY: Integer; sAngle, eAngle: Extended; maxRad: Integer; out oX, oY: Integer);
var
  angle: Extended;
  radius: Extended;
  xShift, yShift: Integer;
begin

  if (eAngle < sAngle) then
    swap(eAngle, sAngle);

  { random angle about the center }
  angle := sAngle + (eAngle-sAngle)*_gaussRand()/2.0;

  { get normal pt about zero, where 68% lie within .5*maxRad }
  radius := gaussRand(0, maxRad * 0.2);

  { the shifting distance based on the radius and angle (both rand) }
  xShift := round(radius * Cos(angle));
  yShift := round(radius * Sin(angle));

  oX := cX + xShift;
  oY := cY + yShift;
end;

function gaussRangeExt(minI, maxI: Extended): Extended;
var
  Valid: Boolean;
  mean: Extended;
  dev: Extended;
  t: Integer;
begin
  { calculate the mean }
  mean := (maxI+minI)/2.0;
  dev  := abs(maxI-minI)/2.0 * __gaussRange;

  t := 0;
  while ((not Valid) and (t < 100)) do
  begin
    Result := gaussRand(mean, dev);
    valid := ((Result >= minI) and (Result <= MaxI));

    inc(t);
  end;

  if (not Valid) then
    RaiseException(erMathError, 'gaussRangeExt failure');
end;

function gaussRangeInt(minI, maxI: Integer): Integer;
begin
  Result := Round(gaussRangeExt(minI, maxI));
end;

procedure gaussBox(out p: TPoint; box: TBox);
begin
  p.x := gaussRangeInt(box.x1, box.x2);
  p.y := gaussRangeInt(box.y1, box.y2);

  if (not PointInBox(p, box)) then
    writeln('gaussBox', Format('Point invalid (%d, %d)', [p.x, p.y]));
end;

function gaussRandom(maxExt: Integer): Integer;
begin
  Result := gaussRangeInt(0, maxExt-1);
end;
