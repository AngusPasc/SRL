const
  __gauss_norm_0 = 0.029899776;
  __gauss_norm_1 = 0.008355968;
  __gauss_norm_2 = 0.076542912;
  __gauss_norm_3 = 0.252408784;
  __gauss_norm_4 = 3.949846138;

var
  __gaussPoint: Extended = 0.4;
  __gaussRange: Extended = 0.3;

  
function TruncedGauss(Lo:Double=0; Hi:Double=1): Double;
const LIMIT = 5.5;
begin
  Result := Abs(Sqrt(-2 * Ln(Random())) * Cos(2 * PI * Random()));
  Result := MinE(Result, LIMIT);
  Result := Result / LIMIT * (Hi-Lo) + Lo;
end;
  
function _gaussPoly(r, rsqr: Extended): Extended;
begin
  Result := __gauss_norm_0 * rsqr + __gauss_norm_1;
  Result := Result * rsqr + __gauss_norm_2;
  Result := Result * rsqr + __gauss_norm_3;
  Result := Result * rsqr + __gauss_norm_4;
  Result := Result * r;
end;

function _gaussRand(): Extended;
begin
  Result := sqrt(-2.0*ln(MaxE(Random(),3.72665E-6))) * cos(2.0*PI*Random());
end;

function GaussRand(mean, dev: Extended): Extended;
begin
  result := mean + dev * _gaussRand();
end;

(*
gauss
~~~~~

.. code-block:: pascal

    function gauss(): Extended;

Calculates a standard normal value (N(0, 1)). By definition, 68.2% of points
will lie within +/- 1*sigma, 95.4% within +/- 2.

.. note::

    - by: Nava2

*)
function Gauss(): Extended;
var
  r: Extended;
  i: Integer;
begin
  r := 0.0;
  for i := 0 to 11 do
    r := r + (random(High(Integer))*1.0)/High(Integer);

  r := (r-6.0)/4.0 ;
  result := _gaussPoly(r, r*r);
end;

(*
gaussPoint
~~~~~~~~~~~

.. code-block:: pascal

    procedure gaussPoint(cX, cY: Integer; sAngle, eAngle: Extended; maxRad: Integer; out oX, oY: Integer);

Calculates a point about cX, cY with radius maxRad. The sangle and eangle are
in radians. The point is returned in the reference parameters oX, oY.

.. note::

    - by: Nava2

Example:

.. code-block:: pascal

    var
      gX, gY: Integer;
    begin
      // get a gaussian pt in a circle:
      gaussPoint(MMCX, MMCY, 0, math_2PI, MMX2-MMCX, gX, gY);
      WriteLn(Format("gX, gY -> %d, %d", gX, gY);
    end;
*)
function GaussPoint(Center: TPoint; sAngle, eAngle: Extended; maxRad: Integer): TPoint;
var
  angle: Extended;
  radius: Extended;
  xShift, yShift, t: Integer;
  Valid: Boolean = False;
begin
  if (eAngle < sAngle) then
    Swap(eAngle, sAngle);

  t := 0;
  while ((not Valid) and (t < 100)) do
  begin
    { random angle about the center }
    angle := sAngle + (eAngle-sAngle)*_gaussRand()/2.0;

    { get normal pt about zero, where 68% lie within .5*maxRad }
    radius := gaussRand(0, maxRad * 0.2);

    { the shifting distance based on the radius and angle (both rand) }
    xShift := Round(radius * Cos(angle));
    yShift := Round(radius * Sin(angle));

    Result.X := Center.X + xShift;
    Result.Y := Center.Y + yShift;

    valid := (Distance(Center.X, Center.Y, Result.X, Result.Y) <= maxRad);
    Inc(t);
  end;
end;

function GaussRangeExt(minI, maxI: Extended): Extended;
var
  Valid: Boolean = False;
  mean: Extended;
  dev: Extended;
  t: Integer;
begin
  { calculate the mean }
  mean := (maxI+minI)/2.0;
  dev  := abs(maxI-minI)/2.0 * __gaussRange;

  t := 0;
  while ((not Valid) and (t < 100)) do
  begin
    Result := gaussRand(mean, dev);
    valid := ((Result >= minI) and (Result <= MaxI));

    Inc(t);
  end;

  if (not Valid) then
    RaiseException(erMathError, 'gaussRangeExt failure');
end;

function GaussRangeInt(minI, maxI: Integer): Integer;
begin
  Result := Round(gaussRangeExt(minI, maxI));
end;

function GaussBox(const Box: TBox): TPoint;
begin
  Result.X := gaussRangeInt(Box.x1, Box.x2);
  Result.Y := gaussRangeInt(Box.y1, Box.y2);

  if (not PointInBox(Result, box)) then
    writeln('gaussBox', Format('Point invalid (%d, %d)', [Result.X, Result.Y]));
end;

function GaussRandom(maxExt: Integer): Integer;
begin
  Result := gaussRangeInt(0, maxExt-1);
end;
