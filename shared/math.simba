(*
Math
====

This file stores math utility functions that don't quite fit in Simba or Lape.

*)

{$f-}

(*
var Max Integer
~~~~~~~~~~~~~~~

Globals that store the max value of signed and non-signed Integers.
*)
const
  MaxInt: Integer = High(Integer);
  MaxUInt: UInt32 = High(UInt32);

{*
var Gauss Internal
~~~~~~~~~~~~~~~~~~

Internal global gaussian variables and constants.
*}
{$IFNDEF CODEINSIGHT}
var
  __gaussPoint: Extended;
  __gaussRange: Extended;
{$ENDIF}

{$IFNDEF CODEINSIGHT}
const
  __gauss_norm_0 = 0.029899776;
  __gauss_norm_1 = 0.008355968;
  __gauss_norm_2 = 0.076542912;
  __gauss_norm_3 = 0.252408784;
  __gauss_norm_4 = 3.949846138;
{$ENDIF}

(*
LimitBox
~~~~~~~~

.. code-block:: pascal

    function LimitBox(const Box: TBox; const Box2: TBox): TBox;

Limits the box bounds to another Box 'Box2'.

.. note::

    by Olly

Example:

.. code-block:: pascal

    Writeln(LimitBox(IntToBox(200, 200, 400, 400), IntToBox(250, 250, 350, 350)));
*)
function LimitBox(const Box: TBox; const Box2: TBox): TBox;
begin
  Result.X1 := Max(Box2.X1, Box.X1);
  Result.Y1 := Max(Box2.Y1, Box.Y1);
  Result.X2 := Min(Box2.X2, Box.X2);
  Result.Y2 := Min(Box2.Y2, Box.Y2);
end;

(*
BoxDimensions
~~~~~~~~~~~~~

.. code-block:: pascal

    procedure BoxDimensions(Box: TBox; out w, h: Integer);

Returns the boxes dimensions'.

.. note::

    by Olly

Example:

.. code-block:: pascal

    BoxDimensions(Box, Width, Height);
*)
procedure BoxDimensions(Box: TBox; out w, h: Integer);
begin
  w := (Box.X2 - Box.X1) + 1;
  h := (Box.Y2 - Box.Y1) + 1;
end;

(*
CombineBoxes
~~~~~~~~~~~~

.. code-block:: pascal

    function CombineBoxes(a, b: TBox): TBox;

Combines both boxes into one.

.. note::

    by Olly

Example:

.. code-block:: pascal

    Writeln(CombineBoxes(Box1, Box2));
*)
function CombineBoxes(a, b: TBox): TBox;
begin
  Result.X1 := Min(Min(a.X1, a.X2), Min(b.X1, b.X2));
  Result.Y1 := Min(Min(a.Y1, a.Y2), Min(b.Y1, b.Y2));
  Result.X2 := Max(Max(a.X1, a.X2), Max(b.X1, b.X2));
  Result.Y2 := Max(Max(a.Y1, a.Y2), Max(b.Y1, b.Y2));
end;

(*
BoxClosestPoint
~~~~~~~~~~~~~~~

.. code-block:: pascal

    function BoxClosestPoint(p : TPoint; b : TBox) : TPoint;

There are 'nine' places where the point can be (relative to a box)..
The middle, 5, is the box itself.
The rest looks like this:

|    1 | 2 | 3
|    ---------
|    4 | 5 | 6
|    ---------
|    7 | 8 | 9

Place 9 means it's past the b.x2, and past the b.y2,
therefore the smallest dist between the point and the box is the
distance between the point and the box's x2,y2 coordinate.

.. note::

    by Raym0nd

Example:

.. code-block:: pascal

*)
function BoxClosestPoint(p : TPoint; b : TBox) : TPoint;
var
  column,row,place : integer;
begin
  result := Point(-1,-1);

  if (p.x < B.X1) then
    Column := 1
  else if (p.x > b.x2) then
    Column := 3
  else
    Column := 2;

  if (p.y < b.y1) then
    row := 1
  else if (p.y > b.y2) then
    row := 3
  else
    row := 2;

  place := (row-1)* 3 + column;
  case Place of
    1 : Result := Point(b.x1,b.y1);
    2 : Result := Point(p.x,b.y1);
    3 : Result := point(b.x2,b.y1);
    4 : Result := point(b.x1,p.y);
    5 : Result := p;
    6 : Result := point(b.x2,p.y);
    7 : Result := point(b.x1,b.y2);
    8 : Result := point(p.x,b.y2);
    9 : Result := point(b.x2,b.y2);
  end;
end;

(*
ExplodeBox
~~~~~~~~~~

.. code-block:: pascal

    function ExplodeBox(bx: TBox; rows, columns: integer): TBoxArray;

Splits the box 'bx' into a TBoxArray with x amount of rows, and x amount of columns.

.. note::

    by Janilabo

Example:

.. code-block:: pascal

    Boxes := ExplodeBox(Box, 20, 20);
*)
function ExplodeBox(bx: TBox; rows, columns: integer): TBoxArray;
var
  r, c, w, h, ew, eh, ow, oh, i, x, y: integer;
begin
  if ((rows > 0) and (columns > 0) and (bx.X1 <= bx.X2) and (bx.Y1 <= bx.Y2)) then
  begin
    w := ((bx.X2 - bx.X1) + 1);
    h := ((bx.Y2 - bx.Y1) + 1);
    if (rows < 1) then
      rows := 1
    else
      if (rows > h) then
        rows := h;
    if (columns < 1) then
      columns := 1
    else
      if (columns > w) then
        columns := w;
    w := (w div columns);
    h := (h div rows);
    ew := (((bx.X2 - bx.X1) + 1) - (w * columns));
    eh := (((bx.Y2 - bx.Y1) + 1) - (h * rows));
    SetLength(Result, (rows * columns));
    y := bx.Y1;
    for r := 0 to (rows - 1) do
    begin
      x := bx.X1;
      if ((eh > 0) and (r < eh)) then
        oh := 1
      else
        oh := 0;
      for c := 0 to (columns - 1) do
      begin
        if ((ew > 0) and (c < ew)) then
          ow := 1
        else
          ow := 0;
        i := ((r * columns) + c);
        Result[i].X1 := x;
        Result[i].X2 := (x + (w - 1) + ow);
        Result[i].Y1 := y;
        Result[i].Y2 := (y + (h - 1) + oh);
        x := (Result[i].X2 + 1);
      end;
      y := (Result[i].Y2 + 1);
    end;
  end else
    SetLength(Result, 0);
end;

(*
GridBox
~~~~~~~

.. code-block:: pascal

    function GridBox(Slot, Columns, Rows, w, h, diffX, diffY: Integer; StartPoint: TPoint): TBox;

Returns a TBox of the slot 'slot' in a grid created by the other parameters.
Slots start with 0 being the top left of the grid, and counting accross.

    * columns: number of columns in the grid
    * rows: number of rows in the grid
    * w: the width of each box in the grid
    * h: the height of each box in the grid
    * diffX: pixels from center to center (x)
    * diffY: pixels from center to center (y)
    * starTPoint: the center point of the top left box in the grid

.. note::

    - by Coh3n
    - Last Modified: Jan. 25th, 2012 by Coh3n

Example:

.. code-block:: pascal

    Result := GridBox(Slot, 4, 2, 95, 80, 0, 150, point(110, 100));
*)
function GridBox(Slot, Columns, Rows, w, h, diffX, diffY: Integer; StartPoint: TPoint): TBox;
begin
  if (Slot > (Columns * Rows)) then
  begin
    Writeln('GridBox: Invalid slot: ' + intToStr(slot));
    Result := IntToBox(0, 0, 0, 0);
    Exit();
  end;

  Result.x1 := (StartPoint.x + ((Slot mod Columns) * diffX) - (w div 2));
  Result.y1 := (StartPoint.y + ((Slot div Columns) * diffY) - (h div 2));
  Result.x2 := (Result.x1 + w);
  Result.y2 := (Result.y1 + h);
end;

(*
Grid
~~~~

.. code-block:: pascal

    function Grid(Columns, Rows, w, h, diffX, diffY: Integer; StartPoint: TPoint): TBoxArray;

Returns a grid of TBoxes (see GridBox for parameters).

.. note::

    - by Coh3n
    - Last Modified: Jan. 25th, 2012 by Coh3n

Example:

.. code-block:: pascal

    Boxes := Grid(5, 10, 20, 20, 25, 25, Point(30, 30));
*)
function Grid(Columns, Rows, w, h, diffX, diffY: Integer; StartPoint: TPoint): TBoxArray;
var
  i: Integer;
begin
  SetLength(Result, (Columns * Rows));

  for i := 0 to High(Result) do
    Result[i] := GridBox(i, Columns, Rows, w, h, diffX, diffY, StartPoint);
end;

(*
GroupDigits
~~~~~~~~~~~

.. code-block:: pascal

    function GroupDigits(N: Integer; token: String): String;

Nicely formats the number passed by placing *token* in between groups of three
numbers.

.. note::

    - by PriSoner and Nava2

Example:

.. code-block:: pascal

    foo := groupDigits(1000, ','); // foo -> '1,000'
    bar := groupDigits(1500423, ' '); // bar -> '1 500 423'
*)
function GroupDigits(N: Integer; token: String): String;
var
  b: Integer;
begin
  Result := IntToStr(n);

  b := Length(Result) + 1;
  if (b > 3) then
  repeat
    b := b - 3;
    if (b > 1) then
      Insert(token, Result, b);
  until (b < 3);
end;

(*
GroupDigits; overload
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function GroupDigits(n: Extended; token: String): String; overload;

Nicely formats the number passed by placing *token* in between groups of three
numbers. Uses extended format instead of integer

.. note::

    - by PriSoner and Nava2

Example:

.. code-block:: pascal

    foo := groupDigits(1000, ','); // foo -> '1,000'
    bar := groupDigits(1500423, ' '); // bar -> '1 500 423'
*)
function GroupDigits(n: Extended; token: String): String; overload;
var
  b: Integer;
begin
  Result := FloatToStr(n);

  b := Pos('.', Result);
  if (b < 1) then
    b := Length(result) + 1;

  if (b > 3) then
  repeat
    b := b - 3;
    if (b > 1) then
      Insert(token, Result, b);
  until (b < 3);
end;

(*
TPABetweenPoints
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TPABetweenPoints(P1, P2: TPoint; Interval, Rand: Integer): TPointArray;

Generates a TPA between P1 and P2, Interval between points; Rand randomness
on each point. Very useful for generating a random walking path between the
player's position and the ending position.

.. note::

      Author: Nava2
      Last Modified: Apr. 4th, 2012 by Coh3n

Example:

.. code-block:: pascal

    newTPA := TPABetweenPoints(PlayerPos, EndPos, 25, 10);
*)
function TPABetweenPoints(P1, P2: TPoint; Interval, Rand: Integer): TPointArray;
var
  hyp, xR, yR: Extended;
  l: Integer;
begin
  // set Result Length and first point at initial Point
  SetLength(Result, Ceil(Distance(P1.X, P1.y, P2.X, P2.Y) * 1.0 / Interval) + 1);
  Result[0] := P1;

  // if no need for intermediate Points then nvm. :)
  if (Distance(P1.X, P1.Y, P2.X, P2.Y) <= Interval) then
  begin
    Result[High(Result)] := P2;
    Exit;
  end;

  // ratios for 'Similar Triangles' maths
  hyp := Hypot(P1.X - P2.x, P1.Y - P2.Y);
  xR := (P2.X - P1.X) / hyp;
  yR := (P2.Y - P1.Y) / hyp;

  // set points
  for l := High(Result) - 1 downto 1 do
  begin
    Result[l].X := Round(P1.X + l * Interval * xR) + RandomRange(-Rand, Rand);
    Result[l].Y := Round(P1.Y + l * Interval * yR) + RandomRange(-Rand, Rand);
  end;

  // last point is tT
  Result[High(Result)] := P2;
end;

(*
quickTBASort
~~~~~~~~~~~~

.. code-block:: pascal

    procedure QuickTBASort(var A: TIntegerArray; var B: TBoxArray; iLo, iHi: Integer; SortUp: Boolean);

Sorts a given TBoxArray

.. note::

      Author: Olly
      Last Modified: 1st February 2014 by Olly

Example:

.. code-block:: pascal

    QuickTBASort(DistArr, BoxArray, 0, l, True);
*)
procedure QuickTBASort(var A: TIntegerArray; var B: TBoxArray; iLo, iHi: Integer; SortUp: Boolean);
var
  Lo, Hi, Mid, T: Integer;
  TP: TBox;
begin
  if (Length(A) <> Length(B)) then
    Exit;
  Lo := iLo;
  Hi := iHi;
  Mid := A[(Lo + Hi) shr 1];
  repeat
    if SortUp then
    begin
      while (A[Lo] < Mid) do Inc(Lo);
      while (A[Hi] > Mid) do Dec(Hi);
    end else
    begin
      while (A[Lo] > Mid) do Inc(Lo);
      while (A[Hi] < Mid) do Dec(Hi);
    end;
    if (Lo <= Hi) then
    begin
      T := A[Lo];
      A[Lo] := A[Hi];
      A[Hi] := T;
      TP := B[Lo];
      B[Lo] := B[Hi];
      B[Hi] := TP;
      Inc(Lo);
      Dec(Hi);
    end;
  until Lo > Hi;
  if (Hi > iLo) then
    QuickTBASort(A, B, iLo, Hi, SortUp);
  if (Lo < iHi) then
    QuickTBASort(A, B, Lo, iHi, SortUp);
end;

(*
SortBoxes
~~~~~~~~~

.. code-block:: pascal

    procedure SortBoxes(var BoxArray: TBoxArray; const From: TPoint);

Sorts a TBoxArray from the TPoint 'from' based from the middle of each box.

.. note::

      Author: Simba source
      Last Modified: 1st February 2014 by Olly

Example:

.. code-block:: pascal

    SortBoxes(Boxes, Point(50, 50));
*)
procedure SortBoxes(var BoxArray: TBoxArray; const From: TPoint);
Var
  I, L: Integer;
  Mid: TPoint;
  DistArr: TIntegerArray;
Begin
  L := High(BoxArray);
  if (L < 0) then
    Exit();

  SetLength(DistArr, L + 1);
  for i := 0 To L do
  begin
    Mid := MiddleBox(BoxArray[i]);
    DistArr[i] := Round(Sqr(From.X - mid.X) + Sqr(From.Y - mid.Y));
  end;

  QuickTBASort(DistArr, BoxArray, 0, l, True);
end;

{*
__gaussPoly
~~~~~~~~~~~

.. code-block:: pascal

    function __gaussPoly(r, rsqr: Extended): Extended;

Helper method for cal_normal_random. Does polynomial calculation using the
`Horner Scheme`_

..http://en.wikipedia.org/wiki/Horner_scheme

.. note::

    - by: Nava2

*}
function __gaussPoly(r, rsqr: Extended): Extended;
begin
  Result := __gauss_norm_0 * rsqr + __gauss_norm_1;
  Result := Result * rsqr + __gauss_norm_2;
  Result := Result * rsqr + __gauss_norm_3;
  Result := Result * rsqr + __gauss_norm_4;
  Result := Result * r;
end;

(*
gauss
~~~~~

.. code-block:: pascal

    function gauss(): Extended;

Calculates a standard normal value (N(0, 1)). By definition, 68.2% of points
will lie within +/- 1*sigma, 95.4% within +/- 2.

.. note::

    - by: Nava2

*)
function gauss(): Extended;
var
  r: Extended;
  i: Integer;
begin
  r := 0.0;
  for i := 0 to 11 do
    r := r + (random(MaxInt)*1.0)/MaxInt;

  r := (r-6.0)/4.0 ;
  result := __gaussPoly(r, r*r);
end;

{*
__gaussMarsPolar
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function __gaussMarsPolar(): Extended;

Calculates a standard normal value (N(0, 1]).

By definition, 68.2% of points will lie within +/- 1*sigma, 95.4% within +/- 2.

.. note::
    Please use `__gaussRand` instead of this function directly, feel free to
    set `__gaussRand` to this function if you choose.
    Currently, this is the default.

.. note::

    - by: BenLand100

*}
{$IFNDEF CODEINSIGHT}
function __gaussRand(): Extended;
begin
  Result := sqrt(-2.0*ln(RandomE()))*cos(2.0*PI*RandomE());
end;
{$ENDIF}

(*
gaussRand
~~~~~~~~~

..code-block:: pascal

    function gaussRand(mean, dev: Extended): Extended;

Calculates a normally distributed point around mean (u) with a standard
deviation of dev (o).

..note::

    - by: Nava2

Example:

..code-block:: pascal

    // shooting arrows simulation:
    pt := Point(gaussRand(center.x, 0.5), gaussRand(center.y, 0.5));
    WriteLn(Format('Hit the target at (%d, %d).', [pt.x, pt.y]));

*)
function gaussRand(mean, dev: Extended): Extended;
begin
  result := mean + dev*__gaussRand();
end;


(*
gaussPoint
~~~~~~~~~~~

.. code-block:: pascal

    procedure gaussPoint(cX, cY: Integer; sAngle, eAngle: Extended; maxRad: Integer; out oX, oY: Integer);

Calculates a point about cX, cY with radius maxRad. The sangle and eangle are
in radians. The point is returned in the reference parameters oX, oY.

.. note::

    - by: Nava2

Example:

.. code-block:: pascal

    var
      gX, gY: Integer;
    begin
      // get a gaussian pt in a circle:
      gaussPoint(MMCX, MMCY, 0, math_2PI, MMX2-MMCX, gX, gY);
      WriteLn(Format("gX, gY -> %d, %d", gX, gY);
    end;
*)
procedure gaussPoint(cX, cY: Integer; sAngle, eAngle: Extended; maxRad: Integer; out oX, oY: Integer);
var
  angle: Extended;
  radius: Extended;
  xShift, yShift: Integer;
begin

  if (eAngle < sAngle) then
    swap(eAngle, sAngle);

  { random angle about the center }
  angle := sAngle + (eAngle-sAngle)*__gaussRand()/2.0;

  { get normal pt about zero, where 68% lie within .5*maxRad }
  radius := gaussRand(maxRad,maxRad*__gaussPoint) - maxRad;

  { the shifting distance based on the radius and angle (both rand) }
  xShift := round(radius * Cos(angle));
  yShift := round(radius * Sin(angle));

  oX := cX + xShift;
  oY := cY + yShift;
end;

(*
gaussRangeExt
~~~~~~~~~~~~~

.. code-block:: pascal

    function gaussRangeExt(minI, maxI: Extended): Extended;

Returns a number between minI and maxI that is normally distributed in the range.

.. note::

    - by: Nava2

Example:

.. code-block:: pascal

    randMean := gaussRangeExt(0, 20);

*)
function gaussRangeExt(minI, maxI: Extended): Extended;
var
  valid: Boolean = False;
  mean: Extended;
  dev: Extended;
  t: Integer;
begin
  { calculate the mean }
  mean := (maxI+minI)/2.0;
  dev  := abs(maxI-minI)/2.0 * __gaussRange;

  t := 0;
  while ((not valid) and (t < 100)) do
  begin
    Result := gaussRand(mean, dev);
    valid := ((Result >= minI) and (Result <= MaxI));

    inc(t);
  end;

  if (not valid) then
    writeln('-- ERROR: **gaussian failed**');
end;

(*
gaussRangeInt
~~~~~~~~~~~~~

.. code-block:: pascal

    function gaussRangeInt(minI, maxI: Integer): Integer;

See `gaussRangeExt` for more detail. Same function, but with integers.

.. note::

    - by: Nava2

*)
function gaussRangeInt(minI, maxI: Integer): Integer;
begin
  Result := Round(gaussRangeExt(minI, maxI));
end;

(*
gaussRandom
~~~~~~~~~~~

.. code-block:: pascal

    function gaussRandom(maxExt: Integer): Integer;

Computes a normally distributed number in [0, maxExt). Thus, it behaves like
Random() would be expected to. But normally distributed about maxExt/2.

It is a wrapper for `gaussRangeInt`.

.. note::

    - by Nava2

Example:

.. code-block:: pascal

*)
function gaussRandom(maxExt: Integer): Integer;
begin
  Result := gaussRangeInt(0, maxExt-1);
end;

(*
gaussBox
~~~~~~~~

.. code-block:: pascal

    procedure gaussBox(out p: TPoint; const Box: TBox);

Calculates a point normally distributed from the center of the passed box. It
checks for outlying points and will regenerate points if necessary.

.. note::

    - by: Nava2

Example:

.. code-block:: pascal

   gaussBox(Point(50, 50), Box);
*)
procedure gaussBox(out p: TPoint; const Box: TBox);
begin
  p.x := gaussRangeInt(Box.x1, Box.x2);
  p.y := gaussRangeInt(Box.y1, Box.y2);

  if (not PointInBox(p, box)) then
    RaiseException(erMathError, Format('gaussBox: Invaild point (%d, %d)', [p.x, p.y]));
end;

begin
  __gaussPoint := 0.4;
  __gaussRange := 0.3;
end;

{$f+}
